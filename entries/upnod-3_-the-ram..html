<!DOCTYPE html><html><head><meta charset="utf-8" /><title>UPNOD 3: The RAM.</title><link href="../style/bootstrap.min.css" rel="stylesheet" type="text/css" /><link href="../style/font-awesome.min.css" rel="stylesheet" type="text/css" /><link href="../style/ts.theme.dark.css" rel="stylesheet" type="text/css" /><link href="../style/hljs.theme.hybrid.css" rel="stylesheet" type="text/css" /><link href="../style/blog.css" rel="stylesheet" type="text/css" /><link href="../index.xml" rel="alternate" title="UPNOD 3: The RAM. Feed" type /><link href="../media/favicon.ico" rel="icon" type="image/png" /><script src="../js/jquery-2.2.0.min.js" type="text/javascript"></script><script src="../js/jquery.tablesorter.min.js" type="text/javascript"></script><script src="../js/bootstrap.min.js" type="text/javascript"></script><script src="../js/highlight.min.js" type="text/javascript"></script><script src="../js/blog.js" type="text/javascript"></script><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="λ-blog v.1.3.2" name="generator" /><meta content="Idorobots" name="author" /><meta content="Kajetan Rzepecki, Idorobots, dev-blog, devblog, blog, Clojure, Lisp, Erlang, technology, electronics, hacks, computer science" name="keywords" /><meta content="Yes Mom, I *do* robots." name="description" /></head><body><nav class="navbar navbar-default navbar-fixed-top"><div class="container"><div class="navbar-header"><button class="navbar-toggle navbar-brand pull-left" data-target="#navbar-responsive-collapse" data-toggle="collapse" type="button"><div><img src="../media/logo.svg" />idorobots.org</div></button><div class="hidden-xs"><a class="navbar-brand" href=".."><div><img src="../media/logo.svg" />idorobots.org</div></a></div></div><div class="collapse navbar-collapse navbar-right" id="navbar-responsive-collapse"><ul class="nav navbar-nav"><li><a href="https://github.com/Idorobots"><i class="fa fa-github"></i> GitHub</a></li><li><a href="../resume.html"><i class="fa fa-trophy"></i> Resumé</a></li><li><a href="../contact.html"><i class="fa fa-comment"></i> Contact</a></li><li class="divider hidden-sm hidden-md hidden-lg"></li><li class="hidden-sm hidden-md hidden-lg"><a href=".."><i class="fa fa-home"></i> Home</a></li><li class="hidden-sm hidden-md hidden-lg"><a href="../archives.html"><i class="fa fa-archive"></i> Archives</a></li><li class="hidden-sm hidden-md hidden-lg"><a href="../tags/index.html"><i class="fa fa-tags"></i> Tag Cloud</a></li><li class="hidden-sm hidden-md hidden-lg"><a href="../index.xml"><i class="fa fa-feed"></i> Feed</a></li><li class="dropdown hidden-xs"><a href="#"><i class="fa fa-chevron-right"></i></a><ul class="dropdown-menu"><li><a href=".."><i class="fa fa-home"></i> Home</a></li><li><a href="../archives.html"><i class="fa fa-archive"></i> Archives</a></li><li><a href="../tags/index.html"><i class="fa fa-tags"></i> Tag Cloud</a></li><li><a href="../index.xml"><i class="fa fa-feed"></i> Feed</a></li></ul></li></ul></div></div></nav><div class="body-wrap"><article id="page"><div class="container"><header class="page-header"></header><article><header><div class="panel panel-default"><div class="panel-body"><div class="text-center"><h1>UPNOD 3: The RAM.</h1><p>Posted on <time>2016-10-03 22:43</time> by <a href="https://github.com/Idorobots">Idorobots</a></p><nav><a class="tag" href="../tags/ram.html"><span class="label label-info small">RAM</span></a> <a class="tag" href="../tags/upnod.html"><span class="label label-info small">UPNOD</span></a> <a class="tag" href="../tags/vhdl.html"><span class="label label-info small">VHDL</span></a> <a class="tag" href="../tags/z80.html"><span class="label label-info small">Z80</span></a> <a class="tag" href="../tags/electronics.html"><span class="label label-info small">electronics</span></a> <a class="tag" href="../tags/reverse-engineering.html"><span class="label label-info small">reverse engineering</span></a> <a class="tag" href="../tags/vintage-electronics.html"><span class="label label-info small">vintage electronics</span></a></nav></div></div></div></header><p>After a lengthy break I'm back to the <a href='http://blog.idorobots.org/tags/upnod.html'>UPNOD series</a>. This time we'll take a closer look at the dynamic random-access memory (DRAM) circuitry present on the PCB:</p><p><img src="http://blog.idorobots.org/media/upnod3/ramchips.png" alt="RAM chips" /></p><p>As usual, all of my findings can be found <a href='https://github.com/idorobots/upnod-card0117-tn64'>here</a>. <a name="preview-more"></a><h2><a name="ram-chips"></a><a href="#ram-chips">RAM Chips</a></h2></p><p>The circuit uses Hitachi-made <strong>HM4864-P3</strong> 65536-word x 1-bit Dynamic Random Access Memory chips organized in <strong>four banks</strong> of eight chips each. The manufacturer advertises them as:</p><ul><li>fast (<em>200 ns</em> access time),</li><li>low power (<strong>330 mW</strong> active power).</li></ul><p>I sure am glad that my Raspberry Pi runs on only a fraction of the total power this RAM requires - <strong>10.56</strong> freaking Watts - and that's not inclusive of the <a href='#support-circuitry'>support circuitry</a>. ( ͡° ͜ʖ ͡°)</p><p>In terms of operation these chips work similarly to the modern DRAM chips - requiring a periodic, externally triggered memory refresh cycle - except much, <em>much</em> simpler. There's no Double Data Rate (DDR), nor I/O channels and, of course, these are asynchronous. Basically, what we get to work with is a multiplexed address input and a couple of signal lines that control how the address input is interpreted:</p><p><img src="http://blog.idorobots.org/media/upnod3/datasheetrdwr.png" alt="datasheet waveform" /></p><p>To read a memory location, we need to deassert the <code>WE</code> line, put the <em>row address</em> of the memory cell we wish to access onto the <code>ADDRESS</code> lines, assert the <em>row address strobe</em> line (<code>RAS</code>), put the <em>column address</em> onto the <code>ADDRESS</code> lines, assert the <code>CAS</code> line, wait for a while and, finally, we can read the <code>Dout</code> line. Of course, we have to deassert the <code>CAS</code> and <code>RAS</code> lines to end the memory read cycle. Memory write cycle is very similar, except we need to assert the <code>WE</code> line and present valid data onto the <code>Din</code> line <strong>before</strong> we assert the <code>CAS</code> line. The last memory operation we're interested in is the mandatory, periodic memory refresh cycle. There's nothing special to it, it's just a memory read cycle without specifying the column address - a so-called <strong>RAS-only refresh</strong> - as the chip refreshes entire rows at the same time.</p><p>Single bits aren't generally useful for computation, so eight of these chips have to be combined to form a <em>bank</em>. Here's a schematic diagram of such a memory bank used in this telco card:</p><p><img src="http://blog.idorobots.org/media/upnod3/rambank.png" alt="RAM bank" /></p><p>Often times, there is an additional, ninth chip present in each bank which is usually used for data parity checking. This design does not include one, so we can assume that error checking and recovery (if any) is performed in the software (if at all).</p><h2><a name="support-circuitry"></a><a href="#support-circuitry">Support circuitry</a></h2>Z80, the CPU that runs the entire thing, is an 8-bit microprocessor with a 16-bit wide address bus. This means it's not directly compatible with described RAM and needs quite a few glue-logic chips to actually make any use of the memory. In addition to multiplexing the address lines, this glue-logic is responsible for translating Z80 control signals (<code>RD</code>, <code>WR</code>, <code>MREQ</code> and <code>REFSH</code>) into RAM control signals (<code>WE</code>, <code>RAS</code> and <code>CAS</code>) and implementing various other features:<p><img src="http://blog.idorobots.org/media/upnod3/ram.png" alt="RAM" /></p><p>On the Z80 side, we have 16 lines of buffered address <code>BA</code>, data <code>D</code>, write enable <code>WR</code>, <code>MREQ</code> signaling a memory-based operation (contrary to <code>IORQ</code> signaling an IO operation) and <code>RAM-ENABLE</code> coming from the decoder circuit (described in a later post). <code>BA</code> goes to two <code>74LS257</code> selector chips via bank selection/mapping circuit described below. <code>MREQ</code> along with a <code>4&#42;CLK</code> oscillator signal go straight to a <code>74LS164</code> shift register which generates memory cycle steps:</p><ul><li>Initially, the lower half of the <code>BA</code> address is selected on the <code>74LS257</code> selectors.</li><li>When <code>MREQ</code> is asserted so is <code>RAS</code> and the cycle begins.</li><li>The first step selects the upper half of the <code>BA</code> address.</li><li>The second step asserts the <code>CAS</code> line.</li><li>The third and fourth steps do not change anything.</li><li>The fifth step deasserts the <code>RAS</code> line.</li><li>The sixth step deasserts the <code>CAS</code> line.</li><li>The remaining two steps again don't change anything.</li></ul><p>Both <code>RAS</code> and <code>CAS</code> generators involve some basic <code>74XX</code> series gates to facilitate RAM bank selection and memory refresh functionality. This is how a simulated version of this circuit performs:</p><p><img src="http://blog.idorobots.org/media/upnod3/vhdlrdwr.png" alt="VHDL waveform" /></p><p>The first memory access (between <code>A</code> and <code>B</code> markers) shows a memory store operation. It looks fairly similar to the datasheet waveform except for the fact, that the <code>WE</code> line on the RAM is delayed quite significantly resulting in a so-called <strong>read-modify-write</strong> cycle - a single memory read that is closely followed by a memory write to the same location. Curiously enough, the value that is read during the read-modify-write cycle is completely ignored leading to the conclusion that it was either easier to implement, resulted in a more reliable memory refresh or allowed supporting more pin-compatible DRAM chips. I'm leaning towards the third option with a hint of the first one.</p><p>The second memory access (between <code>B</code> and <code>C</code>) shows a memory read operation. This time it looks nearly identical to the datasheet waveform if not for the <em>stray</em> values on the <code>data&#95;in</code> line just after the <code>MREQ</code> is asserted... Wait what!? This is actually an artifact of the simulation software - what were seeing is the contents of the <code>data&#95;out</code> latch from the previous cycle, since both the <code>data&#95;in</code> line and the latched <code>data&#95;out</code> are connected directly to the CPU data bus. We're seeing it because the <code>data&#95;out</code> latch output is enabled too soon by the decoder circuit via the <code>RAM&#95;ENABLE</code> line, however it quickly changes its contents, so this brief fluke seems not to interfere with the rest of the circuit in any way whatsoever.</p><p>The last part of the circuit is the aforementioned bank selection & mapping circuit based on a <code>74LS670</code> register file and a <code>74LS139</code> decoder. Basically, it works as an external IO device that can be written to with a 4-bit value. The upper two bits are used for RAM bank selection while the lower two bits add a constant offset to the currently mapped bank by virtue of two spare address lines going to the <code>74LS257</code>-based address selector. Initially, <code>74LS670</code>'s registers are zeroed-out, so the system boots with the first RAM bank mapped to all four bank locations with no offsets. After booting, the OS is free to map each memory bank to each of the four locations under a specified offset, so in principle it could map a single bank to all four locations all at different offsets, or map four banks at four different locations with no offsets. Having such a configurable and mappable memory surely facilitated easy task switching in the primitive OS that runs on the card.</p><h2><a name="memory-refresh"></a><a href="#memory-refresh">Memory refresh</a></h2>Memory refresh circuitry relies heavily on the Z80's built-in refresh register and the <code>REFSH</code> signal. During each instruction decoding phase Z80 presents the contents of the 7-bit refresh register to the address bus and asserts the <code>REFSH</code> and <code>MREQ</code> lines. This happens to be enough to refresh the memory with little additional circuitry - as described above, <code>RAS</code> and <code>CAS</code> generators incorporate the <code>REFSH</code> signal using a handful of <code>74XX</code> series logic gates. Here's a simulation of <code>NOP</code>-instruction decoding and accompanying refresh cycle:<p><img src="http://blog.idorobots.org/media/upnod3/nop.png" alt="NOP" /></p><p>After the instruction opcode fetch (here resulting in <code>0xF3</code> value on the <code>data</code> bus) the <code>REFSH</code> signal is asserted, and shortly afterwards so is the <code>MREQ</code> signal. This results in a memory read operation taking place under the <em>row address</em> currently pointed to by the Z80 refresh register. The <code>CAS</code> generator circuit ensures that <code>CAS</code> lines on the RAM chips are <strong>not</strong> asserted as long as the <code>REFSH</code> line stays low - the specified row is refreshed, but no particular value is actually read.</p><p>This unique feature of the Z80 processor is very handy, but has a drawback - since memory is refreshed only when an instruction opcode is decoded, some sequences of long instructions might stall the memory refresh long enough to cause data corruption. For instance and for comparison with the <code>NOP</code> instruction above, here's a far "longer" <code>DJNZ</code> instruction:</p><p><img src="http://blog.idorobots.org/media/upnod3/djnz.png" alt="DJNZ" /></p><p>A sequence of <code>DJNZ</code> instructions performs a <em>true</em> memory refresh every <strong>13 cycles</strong> and that's not even getting into Z80 <a href='https://en.wikipedia.org/wiki/Zilog_Z80#Instruction_execution'>instruction prefixes</a>, which would place memory refresh cycles even further apart. As cute as it sounds, it probably never proved to be a problem in practice.</p><p>It would make for a neat factory-equipment-DoS plot for an episode of an 80' version of Mr. Robot, though... ¯&#92;<i>(ツ)</i>/¯</p><footer><div class="row"><div class="hidden-xs col-md-2"></div><div class="col-xs-6 col-md-4"><nav><ul class="pager"><li class="previous"><a href="../entries/using-a-rule-based-system-for-type-inference..html"><i class="fa fa-chevron-left" style="margin-right: 5px;"></i><span class="entry-title">Using a Rule-based System for type inference.</span></a></li></ul></nav></div><div class="col-xs-6 col-md-4"><nav><ul class="pager"></ul></nav></div></div></footer></article><footer><hr /><div class="row"><div class="text-center"><div class="row"><div>Copyright © 2011-2016 Kajetan "Kajtek" Rzepecki</div><div>All writing licensed under <a href="http://creativecommons.org/licenses/by-sa/4.0/" rel="license">CC BY-SA 4.0</a>. All code released under the <a href="../media/LICENSE" rel="license">MIT license</a> unless otherwise specified.</div></div></div><div class="text-center"><p>Powered by <a href="https://github.com/Idorobots/lambda-blog">λ-blog</a>.</p></div></div></footer></div></article></div></body></html>