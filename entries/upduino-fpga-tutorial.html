<!DOCTYPE html><html><head><meta charset="utf-8" /><title>Upduino FPGA tutorial</title><link href="../style/bootstrap.min.css" rel="stylesheet" type="text/css" /><link href="../style/font-awesome.min.css" rel="stylesheet" type="text/css" /><link href="../style/ts.theme.dark.css" rel="stylesheet" type="text/css" /><link href="../style/hljs.theme.hybrid.css" rel="stylesheet" type="text/css" /><link href="../style/blog.css" rel="stylesheet" type="text/css" /><link href="../index.xml" rel="alternate" title="Upduino FPGA tutorial Feed" type /><link href="../media/favicon.ico" rel="icon" type="image/png" /><script src="../js/jquery-2.2.0.min.js" type="text/javascript"></script><script src="../js/jquery.tablesorter.min.js" type="text/javascript"></script><script src="../js/bootstrap.min.js" type="text/javascript"></script><script src="../js/highlight.min.js" type="text/javascript"></script><script src="../js/blog.js" type="text/javascript"></script><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="λ-blog v.1.3.3" name="generator" /><meta content="Idorobots" name="author" /><meta content="Kajetan Rzepecki, Idorobots, dev-blog, devblog, blog, Clojure, Lisp, Erlang, technology, electronics, hacks, computer science" name="keywords" /><meta content="Yes Mom, I *do* robots." name="description" /></head><body><nav class="navbar navbar-default navbar-fixed-top"><div class="container"><div class="navbar-header"><button class="navbar-toggle navbar-brand pull-left" data-target="#navbar-responsive-collapse" data-toggle="collapse" type="button"><div><img src="../media/logo.svg" />idorobots.org</div></button><div class="hidden-xs"><a class="navbar-brand" href=".."><div><img src="../media/logo.svg" />idorobots.org</div></a></div></div><div class="collapse navbar-collapse navbar-right" id="navbar-responsive-collapse"><ul class="nav navbar-nav"><li><a href="https://keybase.io/kajtek/"><i class="fa fa-user"> Keybase</i></a></li><li><a href="https://github.com/Idorobots"><i class="fa fa-github"></i> GitHub</a></li><li><a href="../resume.html"><i class="fa fa-trophy"></i> Resumé</a></li><li><a href="../contact.html"><i class="fa fa-comment"></i> Contact</a></li><li class="divider hidden-sm hidden-md hidden-lg"></li><li class="hidden-sm hidden-md hidden-lg"><a href=".."><i class="fa fa-home"></i> Home</a></li><li class="hidden-sm hidden-md hidden-lg"><a href="../archives.html"><i class="fa fa-archive"></i> Archives</a></li><li class="hidden-sm hidden-md hidden-lg"><a href="../tags/index.html"><i class="fa fa-tags"></i> Tag Cloud</a></li><li class="hidden-sm hidden-md hidden-lg"><a href="../index.xml"><i class="fa fa-feed"></i> Feed</a></li><li class="dropdown hidden-xs"><a href="#"><i class="fa fa-chevron-right"></i></a><ul class="dropdown-menu"><li><a href=".."><i class="fa fa-home"></i> Home</a></li><li><a href="../archives.html"><i class="fa fa-archive"></i> Archives</a></li><li><a href="../tags/index.html"><i class="fa fa-tags"></i> Tag Cloud</a></li><li><a href="../index.xml"><i class="fa fa-feed"></i> Feed</a></li></ul></li></ul></div></div></nav><div class="body-wrap"><article id="page"><div class="container"><header class="page-header"></header><article><header><div class="panel panel-default"><div class="panel-body"><div class="text-center"><h1>Upduino FPGA tutorial</h1><p>Posted on <time>2018-10-07 17:57</time> by <a href="https://github.com/Idorobots">Idorobots</a></p><nav><a class="tag" href="../tags/apio.html"><span class="label label-info small">apio</span></a> <a class="tag" href="../tags/fpga.html"><span class="label label-info small">fpga</span></a> <a class="tag" href="../tags/hardware.html"><span class="label label-info small">hardware</span></a> <a class="tag" href="../tags/upduino.html"><span class="label label-info small">upduino</span></a> <a class="tag" href="../tags/verilog.html"><span class="label label-info small">verilog</span></a></nav></div></div></div></header><p>So, I've got my Upduino boards the other day and found out that the available docs are spread throughout the internet, the code examples don't work or are missing build instructions, and the official manufacturer-supplied tools require multiple hard to remember and follow steps. I figured there's got to be a better way, so I'm describing it here.</p><h2><a name="so-you_ve-got-your-upduino.-what-now_"></a><a href="#so-you_ve-got-your-upduino.-what-now_">So you've got your Upduino. What now?</a></h2><p>Upduino is a dream come true for my 8-years-ago self - a <strong>cheap</strong> FPGA capable of holding nontrivial CPU designs that you can program in an <strong>easy</strong> way. Like an Arduino. Get it? Upduino. Arduino. Almost as if it were on purpose.</p><p><div class="text-center"></p><p><img src="https://blog.idorobots.org/media/upduino/upduino.png" alt="Upduino" /></p><p></div> <a name="preview-more"></a> On this tiny board you'll find among others:</p><ul><li>a Lattice iCE40 UltraPlus FPGA - <strong>5.3K LUTs</strong>, 1Mb SPRAM, 120Kb DPRAM, 8 Multipliers,</li><li><strong>34 GPIO</strong> on 0.1 inch headers,</li><li>SPI Flash,</li><li>RGB LED,</li><li>and 3.3V and 1.2V regulators.</li></ul><p>In a nutshell, a great I/O capability and nothing-to-sneeze-at size for your designs, for the low, low price of <strong>13.99 USD</strong>. What you won't get though, is an in-depth documentation with example programs showcasing all the features of the board. There is however the board schematic available and a simple Blinky project, that assumes an in-depth knowledge of the Lattice tool chain.</p><p>This tutorial will only use open source tools that you can conveniently run from the command line. If you're one of <em>those</em> people that prefer heavy UI-based solutions in the likes of <a href='https://pl.wikipedia.org/wiki/Godzilla'>Xilinx ISE</a>, you probably want to follow <a href='https://hsel.co.uk/2018/05/21/lattice-ice40-ultra-plus-fpga-gnarly-grey-upduino-tutorial-1-the-basics/'>this tutorial instead</a>.</p><h2><a name="environment-setup"></a><a href="#environment-setup">Environment setup</a></h2>As already established, there are several options for programming your Upduino v2.0 board - some of them UI-heavy, others strictly command-line:<ul><li>the manufacturer-supplied <a href='http://www.latticesemi.com/iCEcube2'>iCEcube2</a> - which, having prior experience with some Spartan 3 boards programmed using Xilinx ISE, I really want to stay away from,</li><li><a href='http://www.clifford.at/icestorm/'>Project IceStorm</a> - a fully open-source tool-chain for iCE40 family of FPGAs consisting of all the bits and pieces required in order to compile your Verilog designs, place-and-route them and upload them to the board <em>(guess which one we're going to use)</em>,</li><li><a href='https://github.com/FPGAwars/apio'>APIO</a> - <em>SIKE!</em> We're going to use this one. Well, both actually...</li></ul><p>APIO is a nice option if you're looking for an environment that is easy to setup and get going quickly, so that's what we're going to use in this tutorial. Install it using your favorite package manager, or PIP:</p><p><div class="row"><div class="col-xs-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3"></p><pre><code class="bash">yaourt -Sy apio     # For Arch Linux.
pip install -U apio # When in doubt, you can install it this way.
</code></pre><p></div></div></p><p>...and then install all the required tools locally for APIO:</p><p><div class="row"><div class="col-xs-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3"></p><pre><code class="bash">apio install system icestorm scons iverilog
</code></pre><p></div></div></p><p>That's it.</p><h2><a name="blinky"></a><a href="#blinky">Blinky</a></h2>To get you started we'll create a simple RBG blinky using APIO & Verilog. Project setup is very simple, just run the following commands:<p><div class="row"><div class="col-xs-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3"></p><pre><code class="bash">cd path/to/your/new/project
apio init -b upduino2 -p .
</code></pre><p></div></div></p><p>This will create an APIO project file in the <code>path/to/your/new/project</code> directory. Now we can add some source files starting with the package pin mappings (create a file named <code>up5k.pcf</code> and put the following I/O mapping in there):</p><p><div class="row"><div class="col-xs-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3"></p><pre><code class="verilog">set&#95;io --warn-no-port led&#95;blue 39
set&#95;io --warn-no-port led&#95;green 40
set&#95;io --warn-no-port led&#95;red 41
</code></pre><p></div></div></p><p>This lets our tool-chain know, that the <code>led&#95;blue</code>, <code>led&#95;green</code> and <code>led&#95;red</code> signals should be mapped to iCE40 PFGA package pins 39, 40 and 41 respectively. Now for the actual source code (put it into <code>blinky.v</code> file):</p><p><div class="row"><div class="col-xs-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3"></p><pre><code class="verilog">module blinky &#40;output wire led&#95;blue,
               output wire led&#95;green,
               output wire led&#95;red&#41;;

   wire clk;
   SB&#95;HFOSC inthosc&#40;.CLKHFPU&#40;1'b1&#41;, .CLKHFEN&#40;1'b1&#41;, .CLKHF&#40;clk&#41;&#41;;

   localparam N = 27;
   reg &#91;N:0&#93; counter;

   always @&#40;posedge clk&#41;
     counter &lt;= counter + 1;

   assign led&#95;blue = counter&#91;N&#93;;
   assign led&#95;green = counter&#91;N-1&#93;;
   assign led&#95;red = counter&#91;N-2&#93;;
endmodule
</code></pre><p></div></div></p><p>The program defines a module called <code>blinky</code> that uses our three LED wires that we've mapped to the correct (trust me) pins of the chip package. The <code>blinky</code> module then proceeds to connect the <code>clk</code> signal to the internal high-frequency oscillator (line 6), which it then uses to define a very simple 27-bit counter called <code>counter</code>. On each positive edge transition of the <code>clk</code> signal (which is our internal, high-frequency oscillator, mind you) the counter will add 1 to its value. Lastly, the three most significant bits of the <code>counter</code> are then connected to blue, green and red LED signals respectively.</p><p>Upon execution we expect the counter to keep incrementing eventually changing the three most significant bits and, in turn, changing the three different LED colors.</p><p>Now is the time to connect your Upduino board to your laptop and program it:</p><p><div class="row"><div class="col-xs-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3"></p><pre><code class="bash">apio verify # Verifies the correctness of the Verilog code.
apio build  # Compiles the code &amp; prepares a bitstream ready for uploading.
apio upload # Uploads the bitstream to the board.
</code></pre><p></div></div></p><p>If everything went according to the plan, your Upduino will now start very slowly increasing its temperature until it reaches the temperature of a TOKAMAK fusion reactor and burns down your house. You. Are. Welcome.</p><h2><a name="improved-blinky"></a><a href="#improved-blinky">Improved blinky</a></h2><p>Obviously, the previous example isn't ideal - the LED is not current-limited resulting in the whole board getting uncomfortably warm to the touch. Also, if you are wondering about the <code>SB&#95;HFOSC</code> thing in the code, and why it needs to be there, you are not alone, I was pretty confused as well when I tried piecing some working examples together. Let's tackle these problems one by one.</p><p>The <code>SB&#95;HFOSC</code> is a Lattice-supplied module that is conveniently doing a lot of niceties for us - it connects the wire that we give it to the internal high-frequency oscillator, and the sixth line of the previous example just istantiates that module. Of course, there are more of these convenient pieces of code that are waiting for you to explore and re-use in your designs - it's like a <a href='https://Fwww.latticesemi.com/~/media/LatticeSemi/Documents/TechnicalBriefs/SBTICETechnologyLibrary201608.pdf'>standard library of sorts</a>.</p><p>Among the depths of that file you'll likely find the <code>SB&#95;RGBA&#95;DRV</code> module, connecting three open-drain pins for the LED outputs, to the LED wires you pass it via the <code>RGB#</code> parameters. Sound rather well-suited for our purposes, especially the <code>driver</code> part - internally it modulates the power passed on to the LEDs using PWM. We can even adjust the current that the LEDs will be driven with! Given that knowledge, we can fix the other problem with the original blinky design:</p><p><div class="row"><div class="col-xs-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3"></p><pre><code class="verilog">module blinky &#40;output wire led&#95;blue,
               output wire led&#95;green,
               output wire led&#95;red&#41;;

   wire clk;
   SB&#95;HFOSC inthosc&#40;.CLKHFPU&#40;1'b1&#41;, .CLKHFEN&#40;1'b1&#41;, .CLKHF&#40;clk&#41;&#41;;

   localparam N = 27;
   reg &#91;N:0&#93; counter;

   always @&#40;posedge clk&#41;
     counter &lt;= counter + 1;

   SB&#95;RGBA&#95;DRV rgb &#40;
     .RGBLEDEN &#40;1'b1&#41;,
     .RGB0PWM  &#40;counter&#91;N&#93;&#41;,
     .RGB1PWM  &#40;counter&#91;N-1&#93;&#41;,
     .RGB2PWM  &#40;counter&#91;N-2&#93;&#41;,
     .CURREN   &#40;1'b1&#41;,
     .RGB0     &#40;led&#95;blue&#41;,
     .RGB1     &#40;led&#95;green&#41;,
     .RGB2     &#40;led&#95;red&#41;
   &#41;;
   defparam rgb.CURRENT&#95;MODE = &quot;0b1&quot;;
   defparam rgb.RGB0&#95;CURRENT = &quot;0b000001&quot;;
   defparam rgb.RGB1&#95;CURRENT = &quot;0b000001&quot;;
   defparam rgb.RGB2&#95;CURRENT = &quot;0b000001&quot;;
endmodule
</code></pre><p></div></div></p><p>This time we're instantiating two modules - <code>SB&#95;HFOSC</code> for the oscillator and <code>SB&#95;RGBA&#95;DRV</code> for the RGB LED driver. In order to switch the LEDS we're using the PWM-enable signals (<code>RGB#PWM</code> parameters) to turn them on and off according to the state of the <code>counter</code>. Additionally, we're configuring the "half-current" mode (setting the <code>CURRENT&#95;MODE</code> parameter to 1) and setting the lowest possible current values (<code>RGB#&#95;CURRENT</code> parameters), namely 2mA, per LED.</p><p>Running the code now should yield much better results:</p><p><div class="row"><div class="col-xs-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3"></p><pre><code class="bash">apio verify
apio build
apio upload
</code></pre><p></div></div></p><p>The LED should now cycle through different colors without getting excessively hot in the process. That is, assuming that you didn't burn your house down by this point.</p><h2><a name="other-examples"></a><a href="#other-examples">Other examples</a></h2><p>This concludes the tutorial, hopefully it'll help you get started quickly with FPGA programming using the Upduino v2.0 board. The tutorial wouldn't be complete without some pointers to additional code examples, so here are a few:</p><ul><li><a href='https://github.com/gtjennings1/UPDuino_v2_0'>The original RGB Blinky supplied by Gnarly Gray</a></li><li><a href='https://github.com/tomverbeure/upduino'>A working Blinky, that I found very useful in figuring out how to run stuff successfully.</a></li><li><a href='https://github.com/grahamedgecombe/icicle'>The Icicle RISC-V processor that can be run on the Upduino</a></li></ul><p>Oh, an you can find the code <a href='https://github.com/Idorobots/upduino-blinky'>here</a>. Happy hacking.</p><p><strong>2019-04-01</strong>: Fixed a bug in the improved version of the blinky and added a link to a Git repository of the code.</p><footer><div class="row"><div class="hidden-xs col-md-2"></div><div class="col-xs-6 col-md-4"><nav><ul class="pager"><li class="previous"><a href="../entries/hacking-huawei-e3372-hilink..html"><i class="fa fa-chevron-left" style="margin-right: 5px;"></i><span class="entry-title">Hacking Huawei E3372 HiLink.</span></a></li></ul></nav></div><div class="col-xs-6 col-md-4"><nav><ul class="pager"></ul></nav></div></div></footer></article><footer><hr /><div class="row"><div class="text-center"><div class="row"><div>Copyright © 2011-2018 Kajetan "Kajtek" Rzepecki</div><div>All writing licensed under <a href="http://creativecommons.org/licenses/by-sa/4.0/" rel="license">CC BY-SA 4.0</a>. All code released under the <a href="../media/LICENSE" rel="license">MIT license</a> unless otherwise specified.</div></div></div><div class="text-center"><p>Powered by <a href="https://github.com/Idorobots/lambda-blog">λ-blog</a>.</p></div></div></footer></div></article></div></body></html>