<!DOCTYPE html><html><head><meta charset="utf-8" /><title>UPNOD 2: The reset circuit.</title><link href="../style/bootstrap.min.css" rel="stylesheet" type="text/css" /><link href="../style/font-awesome.min.css" rel="stylesheet" type="text/css" /><link href="../style/ts.theme.dark.css" rel="stylesheet" type="text/css" /><link href="../style/hljs.theme.hybrid.css" rel="stylesheet" type="text/css" /><link href="../style/blog.css" rel="stylesheet" type="text/css" /><link href="../index.xml" rel="alternate" title="UPNOD 2: The reset circuit. Feed" type /><link href="../media/favicon.ico" rel="icon" type="image/png" /><script src="../js/jquery-2.2.0.min.js" type="text/javascript"></script><script src="../js/jquery.tablesorter.min.js" type="text/javascript"></script><script src="../js/bootstrap.min.js" type="text/javascript"></script><script src="../js/highlight.min.js" type="text/javascript"></script><script src="../js/blog.js" type="text/javascript"></script><meta content="width=device-width, initial-scale=1.0" name="viewport" /><meta content="λ-blog v.1.3.3" name="generator" /><meta content="Idorobots" name="author" /><meta content="Kajetan Rzepecki, Idorobots, dev-blog, devblog, blog, Clojure, Lisp, Erlang, technology, electronics, hacks, computer science" name="keywords" /><meta content="Yes Mom, I *do* robots." name="description" /></head><body><nav class="navbar navbar-default navbar-fixed-top"><div class="container"><div class="navbar-header"><button class="navbar-toggle navbar-brand pull-left" data-target="#navbar-responsive-collapse" data-toggle="collapse" type="button"><div><img src="../media/logo.svg" />idorobots.org</div></button><div class="hidden-xs"><a class="navbar-brand" href=".."><div><img src="../media/logo.svg" />idorobots.org</div></a></div></div><div class="collapse navbar-collapse navbar-right" id="navbar-responsive-collapse"><ul class="nav navbar-nav"><li><a href="https://github.com/Idorobots"><i class="fa fa-github"></i> GitHub</a></li><li><a href="../resume.html"><i class="fa fa-trophy"></i> Resumé</a></li><li><a href="../contact.html"><i class="fa fa-comment"></i> Contact</a></li><li class="divider hidden-sm hidden-md hidden-lg"></li><li class="hidden-sm hidden-md hidden-lg"><a href=".."><i class="fa fa-home"></i> Home</a></li><li class="hidden-sm hidden-md hidden-lg"><a href="../archives.html"><i class="fa fa-archive"></i> Archives</a></li><li class="hidden-sm hidden-md hidden-lg"><a href="../tags/index.html"><i class="fa fa-tags"></i> Tag Cloud</a></li><li class="hidden-sm hidden-md hidden-lg"><a href="../index.xml"><i class="fa fa-feed"></i> Feed</a></li><li class="dropdown hidden-xs"><a href="#"><i class="fa fa-chevron-right"></i></a><ul class="dropdown-menu"><li><a href=".."><i class="fa fa-home"></i> Home</a></li><li><a href="../archives.html"><i class="fa fa-archive"></i> Archives</a></li><li><a href="../tags/index.html"><i class="fa fa-tags"></i> Tag Cloud</a></li><li><a href="../index.xml"><i class="fa fa-feed"></i> Feed</a></li></ul></li></ul></div></div></nav><div class="body-wrap"><article id="page"><div class="container"><header class="page-header"></header><article><header><div class="panel panel-default"><div class="panel-body"><div class="text-center"><h1>UPNOD 2: The reset circuit.</h1><p>Posted on <time>2016-05-14 21:36</time> by <a href="https://github.com/Idorobots">Idorobots</a></p><nav><a class="tag" href="../tags/6502.html"><span class="label label-info small">6502</span></a> <a class="tag" href="../tags/upnod.html"><span class="label label-info small">UPNOD</span></a> <a class="tag" href="../tags/vhdl.html"><span class="label label-info small">VHDL</span></a> <a class="tag" href="../tags/z80.html"><span class="label label-info small">Z80</span></a> <a class="tag" href="../tags/electronics.html"><span class="label label-info small">electronics</span></a> <a class="tag" href="../tags/reverse-engineering.html"><span class="label label-info small">reverse engineering</span></a> <a class="tag" href="../tags/vintage-electronics.html"><span class="label label-info small">vintage electronics</span></a></nav></div></div></div></header><p>A second installment in the <a href='http://blog.idorobots.org/tags/upnod.html'>UPNOD series</a>, this time we'll take a look into the reset circuitry of the telco card.</p><p><img src="http://blog.idorobots.org/media/upnod2/reset.png" alt="reset" /></p><p>As the title implies, this circuit is responsible for generating a proper Z80' reset sequence. Z80, being a rather dumb piece of clever electronics, may boot up in an undesirable undefined state and requires a few cycles of special treatment to properly initialize internal register values. This circuit does just that - it generates the initial reset pulse and handles reset signals coming from other parts of the board, all while maintaining proper synchronization. <a name="preview-more"></a></p><p>When the board first boots the <code>33uF C3</code> by the <code>74LS132</code> Schmitt trigger NAND ensures that one of the NAND inputs is held low for a certain time making it constantly output a logical high, and in turn a logical low on the <code>RESET</code> line that goes straight to the Z80 causing a reset sequence. Similarly, <code>33uF C2</code> capacitor by the reset switch ensures that the input of the <code>74LS14</code> Schmitt trigger inverter is held low, in turn, ensuring that the <code>74LS74</code> flip-flop is <strong>NOT</strong> reset. Once both <code>C2</code> and <code>C3</code> charge, the Z80 is assumed to be properly initialized, and the <code>74LS132</code> NAND turns into an inverter and operates as such forwards. The <code>Q</code> output of the <code>74LS74</code> flip-flop is initially undefined, but once the initial reset pulse ends the flip-flop itself is put into a reset state by holding its <code>CLR</code> line low forcing the <code>Q</code> output low. This ensures that the <code>74LS123</code> multivibrator configured as a one-shot trigger does <strong>NOT</strong> trigger and doesn't produce a pulse triggering Z80' <code>RESET</code> line to go low. Pressing the reset switch or pulsing one of the FCR-connector inputs disables the <code>74LS74</code> flip-flop <code>CLR</code> line by holding it high, causing a logical high value to be written to its <code>Q</code> output whenever its <code>CLK</code> line transitions from logical low to a logical high. This happens only, when the Z80 performs an instruction fetch and begins to refresh the memory while executing the opcode - the <code>REFSH</code> line goes high and triggers the flip-flop. That in turn triggers the multivibrator producing a new reset pulse for the Z80.</p><p>In sounds overly complex but that's due to the synchronous nature of this circuits operation. Here's how it looks on the PCB:</p><p><img src="http://blog.idorobots.org/media/upnod2/placement.png" alt="placement" /></p><p>The circuit is placed rather neatly on the board with the only issue being the hardware switch, which is quite hard to reach assuming this board was just one of many telco boards of similar size all enclosed in a rack with little to no space between them. I guess you don't want to reset these things all that often.</p><h2><a name="simulation"></a><a href="#simulation">Simulation</a></h2><p>To validate my reverse-engineering attempts I figured it would be nice to simulate parts of the card, and to do that why not to use VHDL, right? Right!? I won't bore you with the gory details, but I've created <a href='https://github.com/idorobots/upnod-card0117-tn64'>a repository</a> containing all the VHDL models along with some simulation results. To run the simulations yourself just navigate your favorite terminal emulator to the <code>vhdl/</code> directory and run:</p><p><div class="row"><div class="col-xs-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3"></p><pre><code class="clojure-repl">$ TARGET=target make view
</code></pre><p></div></div></p><p>...where <code>target</code> names one of the VHDL testbenches in the <code>src/</code> directory. The Makefile assumes you have <code>GHDL</code> and <code>gtkWave</code> installed.</p><p>Here's a top level entity representing the entire reset circuit:</p><p><div class="row"><div class="col-xs-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3"></p><pre><code class="vhdl">entity reset is
  generic &#40;
    PULSE&#95;WIDTH : time;
    ENABLE&#95;DELAY : time
    &#41;;
  port &#40;
    refsh : in std&#95;logic;
    sw&#95;pulse : in std&#95;logic;
    fcr&#95;pulse : in std&#95;logic;
    reset : out std&#95;logic
    &#41;;
end entity;
</code></pre><p></div></div></p><p>It accepts a <code>REFSH</code> line coming from the Z80 mock model along with the FCR-connector line and a switch pulse inputs. It outputs directly to the Z80 <code>RESET</code> line. The entity is built using smaller components, each modeling a discrete chip or a logical part of a discrete <code>74XX</code> series chip. It's worth to mention, that VHDL does not allow simulating analog circuits, so instead I've added configurable time delays where applicable (for instance <code>ENABLE&#95;DELAY</code> above). Here are some simulation results:</p><p><img src="http://blog.idorobots.org/media/upnod2/resetsim.png" alt="resetsim" /></p><p>As can be seen, the model works pretty much as expected, initially performing a long reset pulse and then uniform pulses, synchronized to the positive edge transition of the <code>REFSH</code> line, whenever either FCR-connector line or the reset switch is triggered.</p><h2><a name="action_"></a><a href="#action_">Action!</a></h2><p>...but let's not rely only on models and simulations and actually see this stuff in action! Starting with the initial reset delay circuit:</p><p><div class="row"><div class="col-xs-12 col-md-8 col-md-offset-2 col-lg-6 col-lg-offset-3"></p><p><img src="http://blog.idorobots.org/media/upnod2/delay.png" alt="delay" /></p><p></div></div></p><p>Here are some measurements:</p><p><img src="http://blog.idorobots.org/media/upnod2/delaymeasurement.png" alt="delaymeasurement" /></p><p>The first channel (yellow trace) shows the voltage on the positive lead of the capacitor, the second channel (cyan trace) is the output of the <code>74LS132</code> Schmitt trigger NAND and the third channel (magenta trace) shows the other input of the NAND, which I emulated using a tactile switch and a (not quite) steady hand. As predicted, initially the NAND outputs a constant high state, but once the capacitor is charged to a threshold value of around 1.7 Volts it starts working as an inverter. Keen eyed readers probably noticed that I used different capacitance and resistance values as the capacitor charge curve looks off - I simply did not have any 560k resistors. This means that we can't measure the actual delay, but y'know, I'm pretty sure a few seconds is long enough for the Z80 to initialize.</p><p>Now, for the fun part, let's look closer at the entire reset circuit with a slight modification - instead of a Z80 I'm going to use a 6502. Right now, I only have a single Z80 CPU, and I'm not very keen on frying it on a breadboard.</p><p><div class="text-center"></p><p>( ͡° ͜ʖ ͡°)</p><p></div></p><p>To make the 6502-based circuit functionally equivalent to the Z80 one, some care must be taken. For starters, 6502 doesn't have a <code>REFSH</code> line, so <code>SYNC</code> needs to be used instead. <code>SYNC</code> indicates that the 6502 is fetching an instruction opcode, and it is asserted slightly earlier than the <code>REFSH</code> line on a Z80, but this turned out to be of little significance. Other than that, the 6502-based circuit is pretty much identical and only differs (wildly, I must say) in passive components values - the 6502 runs at a whoopin' <strong>0.6 Hz</strong> and so, various pulse widths were adjusted accordingly. Here are the traces:</p><p><img src="http://blog.idorobots.org/media/upnod2/6502resetmeasurement.png" alt="6502resetmeasurement" /></p><p>This time around the first channel (yellow trace) shows the 0.6 Hz clock signal, the second channel (cyan trace) represents the <code>SYNC</code> line of the 6502, the third channel (magenta trace) is the <code>RESET</code> line of the 6502 and the last channel (blue trace) is me pushing the reset switch at random intervals.</p><p>As can be seen, 6502 does something weird right after the reset sequence ends - it loads a single instruction (a single <code>SYNC</code> assertion right after <code>RESET</code> goes high) and then spends six more cycles doing some black magic. After a rather lengthy investigation it turned out that it was actually writing the contents of the program counter (<code>PC</code>) and the status register to the stack (3 cycles), reading the reset vector found at <code>0xFFFC</code> and <code>0xFFFD</code> offsets in the memory (2 cycles), and then jumping into it (1 cycle). The initial instruction fetch is most likely fake and is treated similarly to the <code>brk</code> instruction, except the reset vector is read instead of the interrupt vector. This behavior, of course, doesn't interfere at all with the reset circuitry - pressing the reset button generates a synchronized reset pulse on the first positive transition of the <code>SYNC</code> line, exactly as it was predicted by the simulation above.</p><p>This concludes the reset circuit reverse-engineering... At least for now, since this particular board has been modified in a few places, one of which uses the <code>RESET</code> line where it was previously absent, but that's a topic for another post in the series.</p><footer><div class="row"><div class="hidden-xs col-md-2"></div><div class="col-xs-6 col-md-4"><nav><ul class="pager"><li class="previous"><a href="../entries/atari-xe-multicart.html"><i class="fa fa-chevron-left" style="margin-right: 5px;"></i><span class="entry-title">Atari XE Multicart</span></a></li></ul></nav></div><div class="col-xs-6 col-md-4"><nav><ul class="pager"><li class="next"><a href="../entries/using-a-rule-based-system-for-type-inference..html"><span class="entry-title">Using a Rule-based System for type inference.</span><i class="fa fa-chevron-right" style="margin-left: 5px;"></i></a></li></ul></nav></div></div></footer></article><footer><hr /><div class="row"><div class="text-center"><div class="row"><div>Copyright © 2011-2017 Kajetan "Kajtek" Rzepecki</div><div>All writing licensed under <a href="http://creativecommons.org/licenses/by-sa/4.0/" rel="license">CC BY-SA 4.0</a>. All code released under the <a href="../media/LICENSE" rel="license">MIT license</a> unless otherwise specified.</div></div></div><div class="text-center"><p>Powered by <a href="https://github.com/Idorobots/lambda-blog">λ-blog</a>.</p></div></div></footer></div></article></div></body></html>